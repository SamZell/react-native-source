/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

package com.facebook.react.bridge.annotations;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import com.facebook.react.bridge.BaseJavaModule;
import com.facebook.react.bridge.ExecutorToken;
import com.facebook.react.bridge.ReactContext;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * Annotation for use on {@link BaseJavaModule}s to describe properties for that module.
 */
@Retention(RUNTIME)
@Target(TYPE)
public @interface ReactModule {
  /**
   * Name used to {@code require()} this module from JavaScript.
   */
  String name();

  /**
   * 如果你打算重写一些其他的本地模块，如注册的部分不同的包（如核心一包）就返回true。试图重写没有返回
   * 真正从此方法被认为是一个错误，并将在初始化过程中抛出一个异常
   * 默认所有模块返回false
   * True if you intend to override some other native module that was registered e.g. as part
   * of a different package (such as the core one). Trying to override without returning true from
   * this method is considered an error and will throw an exception during initialization. By
   * default all modules return false.
   */
  boolean canOverrideExistingModule() default false;

  /**
   * 为了能支持web端的多线程，一个模块必须意识到它可以从多不同的JS VMS被调用。支持web多线程意味着要意识到以下：
   * 1.每一个VM要只有唯一id
   * 2.模块需要去保证入队的回调以及JS模块指向是正确的VM

   *
   * In order to support web workers, a module must be aware that it can be invoked from multiple
   * different JS VMs. Supporting web workers means recognizing things like:
   *
   * 1) ids (e.g. timer ids, request ids, etc.) may only unique on a per-VM basis
   * 2) the module needs to make sure to enqueue callbacks and JS module calls to the correct VM
   *
   * 为了方便，支持Web的线程将支持他们所有的“reactmethod模块—注释的方法通过{@link Executortoken }作为第一个参数
   * 在所有参数从JS之前。这executortoken内部映射到一个特定的JS VM和可以使用的适当地路由调用的框架。为了使JS模块调用正确，开始使用
   * 版本{@链接reactcontext # getjsmodule（executortoken，类）}，以executortoken。它将确保您发送给返回的对象的任何调用都将返回到
   * 正确的虚拟机。在回调的时候，你不需要做什么特别的事情——框架自动标签，它们与正确的executortoken当创建。
   *
   * In order to facilitate this, modules that support web workers will have all their @ReactMethod-
   * annotated methods passed a {@link ExecutorToken} as the first parameter before any arguments
   * from JS. This ExecutorToken internally maps to a specific JS VM and can be used by the
   * framework to route calls appropriately. In order to make JS module calls correctly, start using
   * the version of {@link ReactContext#getJSModule(ExecutorToken, Class)} that takes an
   * ExecutorToken. It will ensure that any calls you dispatch to the returned object will go to
   * the right VM. For Callbacks, you don't have to do anything special -- the framework
   * automatically tags them with the correct ExecutorToken when the are created.
   *
   * Note: even though calls can come from multiple JS VMs on multiple threads, calls to this module
   * will still only occur on a single thread.
   *
   * @return whether this module supports web workers.
   */
  boolean supportsWebWorkers() default false;

  /**
   * Whether this module needs to be loaded immediately.
   */
  boolean needsEagerInit() default false;
}
